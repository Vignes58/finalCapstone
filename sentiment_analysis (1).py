{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 23,
   "id": "13598fd7",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Reviews: This product is amazing! I love it.\n",
      "Sentiment: Positive\n",
      "\n",
      "Reviews: I'm not satisfied with this product. It doesn't work as expected.\n",
      "Sentiment: Negative\n",
      "\n",
      "Reviews: This product seems, okay.\n",
      "Sentiment: Positive\n",
      "\n",
      "Similarity between review 1 and review 2: 0.5644872632355882\n"
     ]
    },
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "C:\\Users\\user\\AppData\\Local\\Temp\\ipykernel_19460\\978969961.py:93: UserWarning: [W007] The model you're using has no word vectors loaded, so the result of the Doc.similarity method will be based on the tagger, parser and NER, which may not give useful similarity judgements. This may happen if you're using one of the small models, e.g. `en_core_web_sm`, which don't ship with word vectors and only use context-sensitive tensors. You can always add your own word vectors, or use one of the larger models instead if available.\n",
      "  similarity_score = doc1.similarity(doc2)\n"
     ]
    }
   ],
   "source": [
    "import pandas as pd\n",
    "import spacy\n",
    "from spacytextblob.spacytextblob import SpacyTextBlob \n",
    "\n",
    "# Load the spaCy model\n",
    "nlp = spacy.load(\"en_core_web_sm\")\n",
    "# Add TextBlob capabilities to spaCy pipeline\n",
    "nlp.add_pipe('spacytextblob')\n",
    "\n",
    "# Step 1: Load and preprocess the data\n",
    "# Assuming you have a dataframe named 'data' with 'review.text' column\n",
    "def load_and_preprocess_data(data):\n",
    "    # Select the 'review.text' column\n",
    "    reviews_data = data['reviews.text']\n",
    "    # Remove missing values\n",
    "    clean_data = data.dropna(subset=['reviews.text'])\n",
    "    return clean_data\n",
    "#C:/Users/user/Desktop/Anna/Python/archive/amazon_product_reviews.csv\n",
    "# Step 2: Create a function for sentiment analysis\n",
    "def analyze_sentiment(reviews):\n",
    "    doc = nlp(reviews)\n",
    "    sentiment = doc._.polarity\n",
    "    return sentiment\n",
    "\n",
    "# Step 3: Test the sentiment analysis function\n",
    "def test_sentiment_analysis():\n",
    "    sample_reviews = [\n",
    "        \"This product is amazing! I love it.\",\n",
    "        \"I'm not satisfied with this product. It doesn't work as expected.\",\n",
    "        \"This product seems, okay.\"\n",
    "    ]\n",
    "    for reviews in sample_reviews:\n",
    "        sentiment = analyze_sentiment(reviews)\n",
    "        if sentiment > 0:\n",
    "            print(f\"Reviews: {reviews}\\nSentiment: Positive\\n\")\n",
    "        elif sentiment < 0:\n",
    "            print(f\"Reviews: {reviews}\\nSentiment: Negative\\n\")\n",
    "        else:\n",
    "            print(f\"Reviews {reviews}\\nSentiment: Neutral\\n\")\n",
    "  #print(f\"Reviews: {reviews}\\nSentiment: Positive\\n\")\n",
    "   # elif sentiment < 0:\n",
    "    #    print(f\"Reviews: {reviews}\\nSentiment: Negative\\n\")\n",
    "    #else:\n",
    "     #   print(f\"Reviews {reviews}\\nSentiment: Neutral\\n\")\n",
    "# Step 4: Write a brief report\n",
    "def write_report():\n",
    "    report = \"\"\"\n",
    "    Sentiment Analysis Report:\n",
    "    \n",
    "Description of the Dataset\n",
    "\n",
    "The dataset is collected from Kaggle website which has a list of over 34,000 consumer reviews for Amazon products. The data was originally sourced from Datafiniti's Product Database and is provided in CSV format. It includes a range of information such as usernames, titles, reviews, ratings, dates, and other relevant attributes associated with each review entry.\n",
    "Details of the preprocessing steps\n",
    "\n",
    "The following steps were taken to preprocess the dataset.\n",
    "\n",
    "1.\tFirstly, the code removes stopwords, non-alphabetic characters, and lemmatizing the remaining words.\n",
    "2.\tRemove missing value in the from the 'reviews.text' column. For this, dropna function was applied to remove a missing value within the 'reviews.text' column. This will ensure data integrity and provide accurate results when applying the sentimental analysis.\n",
    "3.\tHave applied tokenization to break down the text into smaller units and have used SpaCy to tokenise the 'reviews.text' column. \n",
    "4.\tUsing the preprocess text function to review text in the 'reviews.text' column. The cleaned data is stored in a new column named 'cleaned_review'.\n",
    "5.\tUsed the Textblob library to perform sentimental analysis. \n",
    "6.\tA TextBlob object is created from the input review text.\n",
    "7.\tThe polarity score is returned as the output for the sentimental analysis.\n",
    "\n",
    "Evaluation of results\n",
    "\n",
    "The following is my is output result for the sentimental analysis that I have produces: \n",
    "From evaluation my output results, the first two output seems to be accurate. The first output is showing a positive sentiment for the review of a product. The second output is showing a negative sentiment for the review of a product. However, the sentiment classification for the third review seems inaccurate. While the review contains words like \"Better\" and \"Okay\", indicating a potentially neutral sentiment, the model incorrectly classified it as positive. This discrepancy suggests that the model may have misinterpreted certain phrases, highlighting the need for further refinement to better capture nuances in sentiment.\n",
    "Insights into the model's strengths and limitations\n",
    "The following are some of the model’s strengths and limitations: \n",
    "Strengths:\n",
    "•\tTextBlob's sentiment analysis functionality provides quick and efficient sentiment polarity scores.\n",
    "•\tThe output of the sentiment analysis is easy to interpret with polarity scores being Positive, Negative or Neutral.\n",
    "\n",
    "Limitations:\n",
    "•\tThe model could have difficulty analysing mixed/neutral reviews. As mentioned in the evaluation, reviews containing mixed sentiments or conflicting statements may cause challenges for accurate sentiment analysis.\n",
    "•\tThe sentiment analysis may be influenced by biases present in the training data.\n",
    "•\tThe model may misinterpret sarcastic or ironic statements.\n",
    "\n",
    "\n",
    "    \"\"\"\n",
    "    with open(\"sentiment_analysis_report_vigneswaran.doc\", \"w\") as file:\n",
    "        file.write(report)\n",
    "\n",
    "# Step 5: Test similarity of two product reviews\n",
    "def test_similarity(data):\n",
    "    review1 = data['reviews.text'][0]\n",
    "    review2 = data['reviews.text'][1]\n",
    "    \n",
    "    doc1 = nlp(review1)\n",
    "    doc2 = nlp(review2)\n",
    "    \n",
    "    similarity_score = doc1.similarity(doc2)\n",
    "    print(f\"Similarity between review 1 and review 2: {similarity_score}\")\n",
    "\n",
    "# Load the dataset\n",
    "data = pd.read_csv(\"C:/Users/user/Desktop/Anna/Python/archive/amazon_product_reviews.csv\")\n",
    "\n",
    "# Step 1: Load and preprocess the data\n",
    "clean_data = load_and_preprocess_data(data)\n",
    "\n",
    "# Step 2: Create a function for sentiment analysis\n",
    "# Function 'analyze_sentiment' defined above\n",
    "\n",
    "# Step 3: Test the sentiment analysis function\n",
    "test_sentiment_analysis()\n",
    "\n",
    "# Step 4: Write a brief report\n",
    "write_report()\n",
    "\n",
    "# Step 5: Test similarity of two product reviews\n",
    "test_similarity(clean_data)\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "c740f121",
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3 (ipykernel)",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.11.5"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
